# -*- coding: utf-8 -*-
"""AnnualAppraisalTool.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d22cDbiqlAoYfS_w_CqvHoSRfMPUVuv1

# Annual Appraisal Tool

# ReportLab/Holidays - PIP Installation
"""

!pip install reportlab
!pip install holidays
!pip install pdf2image
!apt-get install -y poppler-utils
!pip install PyPDF2 python-docx fpdf pillow

"""# FBD"""

import datetime
import holidays
from IPython.display import display, HTML
import ipywidgets as widgets

# U.S. Federal Holidays
us_holidays = holidays.US()

# Button to trigger deadline calculation
deadline_button = widgets.Button(description='Calculate Filing Deadline', button_style='info')

# Output area
deadline_output = widgets.Output()

# Function to calculate 15 business days from date_received
def calculate_deadline(date_received):
    current_date = date_received
    business_days_count = 0

    while business_days_count < 15:
        current_date += datetime.timedelta(days=1)
        if current_date.weekday() < 5 and current_date not in us_holidays:
            business_days_count += 1

    return current_date

# Button click handler
def on_deadline_button_click(b):
    deadline_output.clear_output()
    if not date_received.value:
        with deadline_output:
            display(HTML("<b style='color:red;'>Please select a Date Received first.</b>"))
        return

    deadline = calculate_deadline(date_received.value)
    with deadline_output:
        display(HTML(f"<b>Filing Deadline (15 business days):</b> {deadline.strftime('%A, %B %d, %Y')}"))

# Attach handler
deadline_button.on_click(on_deadline_button_click)

# Display section
display(widgets.VBox([deadline_button, deadline_output]))

"""# Data Collection"""

from IPython.display import display, clear_output
import ipywidgets as widgets
from datetime import date
import holidays
import datetime

# Global storage
saved_form_data = {}
generated_argument = ""


# --- Define all widgets ---

# Form fields
steward_name = widgets.Text(description='Steward:')
employee_name = widgets.Text(description='Employee:')

# Today's date
today = date.today()

# Check if today is on or after October 1st
if today.month >= 10:
    effective_year = today.year + 1
else:
    effective_year = today.year

# Generate years starting from 2020 up to the effective year
appraisal_year = widgets.Dropdown(
    options=[str(y) for y in range(2023, effective_year + 1)],
    description='Year:'
)

# Create list of options from 1.0 to 5.0 with 0.1 increments
rating_options = [f"{x:.1f}" for x in [i * 0.1 for i in range(10, 51)]]  # 10 to 50 -> 1.0 to 5.0

# Updated widgets
rating_received = widgets.Dropdown(
    options=rating_options,
    description='Rating:'
)

previous_rating = widgets.Dropdown(
    options=rating_options,
    description='Previous Rating:'
)

issue_description = widgets.Textarea(description='Issue:', layout=widgets.Layout(width='500px', height='100px'))
desired_outcome = widgets.Textarea(description='Desired Outcome:', layout=widgets.Layout(width='500px', height='100px'))
date_received = widgets.DatePicker(description='Date Received:')

# Create an empty list first
checkboxes = []

# Populate it now
checkbox_descriptions = [
    'Performance standards did not permit the accurate evaluation of their job performance based on objective criteria related to their position.',
    'Management was given specific distribution amounts per level of rating for employees.',
    'Performance elements were not clearly defined',
    'Employee was not given opportunity to improve',
    'Rating is inconsistent with prior feedback',
    'Rating is inconsistent with peer comparisons'
]
checkboxes = [widgets.Checkbox(description=desc) for desc in checkbox_descriptions]

# Define each checkbox label with its corresponding article and argument ****Need to update this section MATTHEW!!!!
violation_map = {
    "Performance standards did not permit the accurate evaluation of their job performance based on objective criteria related to their position.": {
        "articles": ["Article 12 Section 3, 5 U.S.C §§ 9508, 5 U.S.C. §§ 4302, 5 C.F.R. Part 430"],
        "argument": ( "     Management is supposed to, to the maximum extent feasible, provide an accurate evaluation of an employee’s job performance based on objective criteria"
        " related to the position. By failing to do this, management has failed to follow the guidance provided through the National Agreement, Article 12 Section 3;"
        " 5 USC 4302; 5 USC 9508; 5 CFR Part 430. Each of these specify instructions to how the appraisal system is to work. Each of these consistently state that an accurate"
        " evaluation must be provided to employees. 5 USC 4302 states \“performance standards which will, to the maximum extent feasible, permit the accurate evaluation of job"
        " performance on the basis of objective criteria (which may include the extent of courtesy demonstrated to the public) related to the job in question for each employee or"
        " position under the system.\” By not utilizing performance standards to provide an accurate evaluation, not only violates the employee’s rights granted under the National"
        " Agreement, but also violates the laws and regulations intended to protect federal employees from harm. By failing to utilize the performance standards to the degree at"
        " which they were intended to be used to evaluate an employee’s performance to provide an accurate evaluation of their work, management has failed to comply and created an"
        " unjust and unfair appraisal for this grievant and management needs to reconsider the appraisal score given.\n")
    },
    "Management was given specific distribution amounts per level of rating for employees.": {
        "articles": ["Article 12 Section 3, 5 C.F.R. Part 430.208, IRM 6.430.2.5.7"],
        "argument": ( "     It is highly inappropriate for management to establish and distribute annual appraisals based upon specific distribution amounts per level of rating of employees. By utilizing this system of"
        " restricting the amount allowed per level of rating, management removes the ability for employees to be fairly and accurately rated upon their performance over the year the annual appraisal period covers."
        " IRM 6.430.2.5.7 states \“Presumptive ratings, for ratings of record, are prohibited by 5 CFR Section 430.208 (a)(2).\” It then goes on to say \“A rating of record can be based only on the evaluation of actual"
        " job performance for the designated performance appraisal period. A supervisor must not issue a rating of record that assumes a level of performance by an employee without an actual evaluation of that"
        " employee’s performance.\” Not only is this addressed in the IRM but it is also addressed in C.F.R Part 430.208, which states \“The method for deriving and assigning a summary level may not limit or require the"
        " use of particular summary levels (i.e., establish a forced distribution of summary levels). However, methods used to make distinctions among employees or groups of employees such as comparing, categorizing,"
        " and ranking employees or groups on the basis of their performance may be used for purposes other than assigning a summary level including, but not limited to, award determinations and promotion decisions.\”"
        " By not following the guidance provided through the CFR, the Agency is not only violating the National Agreement, the IRM’s, but is also breaking the law by forcing a set distribution list per level of rating."
        " Management has violated the employee’s rights by failing to provide an accurate reflection upon their service over the last appraisal period of a year and by utilization of a forced distribution of levels of"
        " rating. Management should only utilize the employee’s performance during the period of review and any variation from such is violating the laws and regulations in place to prevent harm.\n")
    },
    "Performance elements were not clearly defined": {
        "articles": ["Article 21, Section 2"],
        "argument": "Performance elements were not defined in a manner that allowed the employee to understand what was expected, violating Article 21, Section 2.\n"
    },
    "Employee was not given opportunity to improve": {
        "articles": ["Article 12, Section 7"],
        "argument": "The employee was not provided timely and constructive feedback or a reasonable opportunity to improve, contrary to Article 12, Section 7.\n"
    },
    "Rating is inconsistent with prior feedback": {
        "articles": ["Article 21, Section 4"],
        "argument": "The rating is inconsistent with previous documented feedback and mid-year reviews, indicating a lack of justification under Article 21, Section 4.\n"
    },
    "Rating is inconsistent with peer comparisons": {
        "articles": ["Article 21, Section 5"],
        "argument": "The rating is significantly lower than peers performing similar duties without justification, suggesting disparate treatment in violation of Article 21, Section 5.\n"
    }
}

# Create 10 file upload widgets
file_uploaders = [widgets.FileUpload(accept='', multiple=False) for _ in range(10)]

# Optional: Label each upload slot
upload_boxes = []
for i, uploader in enumerate(file_uploaders):
    label = widgets.Label(f"Upload Document {i+1}")
    upload_boxes.append(widgets.VBox([label, uploader]))

# Combine all into a display box
upload_section = widgets.VBox(upload_boxes, layout=widgets.Layout(border='1px solid gray', padding='10px'))
upload_title = widgets.HTML("<b>Attach Supporting Documents (up to 10)</b>")

# Add to your existing form layout
display(widgets.VBox([upload_title, upload_section]))

# Main submit button
submit_all_button = widgets.Button(description='Submit All', button_style='success')

# --- Define helper functions ---

# Calculate File-By Date
us_holidays = holidays.US()

def calculate_fbd(start_date):
    if start_date is None:
        return None
    current_date = start_date
    business_days = 0
    while business_days < 15:
        current_date += datetime.timedelta(days=1)
        if current_date.weekday() < 5 and current_date not in us_holidays:
            business_days += 1
    return current_date

# Submission Handler
def on_submit_all(b):
    global saved_form_data, generated_argument  # <-- IMPORTANT

    clear_output()

    # Collect selected checkboxes
    selected_reasons = [cb.description for cb in checkboxes if cb.value]

    if not selected_reasons:
        print("⚠️ Please select at least one grievance reason.")
        display(form_layout)
        return

    intro = "This grievance challenges the annual performance appraisal based on the following concerns:"
    bullet_points = "\n".join([f"- {reason}" for reason in selected_reasons])
    closing = ("\n\nBased on these issues, the appraisal does not appear to reflect a fair and accurate assessment of the employee's performance. "
               "We respectfully request that the appraisal be reviewed and corrected accordingly.")

    generated_argument = f"{intro}\n\n{bullet_points}{closing}"

    fbd = calculate_fbd(date_received.value)

    # Package everything into a global data dictionary
    saved_form_data = {
        'steward_name': steward_name.value,
        'employee_name': employee_name.value,
        'appraisal_year': appraisal_year.value,
        'rating_received': rating_received.value,
        'previous_rating': previous_rating.value,
        'issue_description': issue_description.value,
        'desired_outcome': desired_outcome.value,
        'date_received': date_received.value,
        'file_by_date': fbd,
        'generated_argument': generated_argument
    }

    print("✅ Form Submitted Successfully!\n")
    for key, value in saved_form_data.items():
        print(f"{key}: {value}")

    # 🚀 NOW trigger PDF generation and export immediately
    filename = generate_pdf_with_wrapping(saved_form_data, generated_argument)
    print(f"\n✅ PDF Generated: {filename}")

    display(form_layout)  # Redisplay form for another entry


# Connect button to function
submit_all_button.on_click(on_submit_all)

# Layout: form fields + checkboxes + submit button
form_layout = widgets.VBox([
    steward_name, employee_name, appraisal_year, rating_received, previous_rating,
    issue_description, desired_outcome, date_received,
    widgets.HTML("<h4>Select grievance reasons below:</h4>"),
    *checkboxes,
    submit_all_button
])

# --- Display the full form ---
display(form_layout)

"""# Display Argument"""

import ipywidgets as widgets

# Add a new widget to display the argument
argument_output = widgets.Output()

    # Update on_submit to display the argument in the output widget
def on_submit(b):
    clear_output()
    display(widgets.HTML("<h3>Form Submitted!</h3>"))

        # ... (rest of your on_submit function)

    with argument_output:
            display(widgets.HTML(value=f"<pre>{generated_argument}</pre>"))

        # ... (rest of your on_submit function)

    # Add the argument_output widget to your form_items
form_items = widgets.VBox([steward_name, employee_name, appraisal_year, rating_received, previous_rating, issue_description, desired_outcome, date_received, argument_output])

"""# Clear Form"""

import ipywidgets as widgets
from IPython.display import display

# Output for messages
clear_output_message = widgets.Output()

clear_button = widgets.Button(description='Clear All', button_style='danger')

def clear_checkboxes_and_output(b):
    global generated_argument  # if needed

    try:
        checkboxes_exist = any(cb.value for cb in checkboxes)
    except NameError:
        checkboxes_exist = False

    something_to_clear = (
        checkboxes_exist or
        (generated_argument.strip() if 'generated_argument' in globals() else "") != "" or
        (steward_name.value if 'steward_name' in globals() else "") or
        (employee_name.value if 'employee_name' in globals() else "") or
        (issue_description.value if 'issue_description' in globals() else "") or
        (desired_outcome.value if 'desired_outcome' in globals() else "")
    )

    if not something_to_clear:
        print("No selections made yet to clear.")
        return

    # Clear all fields
    if 'checkboxes' in globals():
        for cb in checkboxes:
            cb.value = False

    if 'steward_name' in globals():
        steward_name.value = ""

    if 'employee_name' in globals():
        employee_name.value = ""

    if 'issue_description' in globals():
        issue_description.value = ""

    if 'desired_outcome' in globals():
        desired_outcome.value = ""

    if 'generated_argument' in globals():
        generated_argument = ""

    # Clear file upload widgets
    if 'file_uploaders' in globals():
        for uploader in file_uploaders:
            uploader.value.clear()
            uploader._counter = 0  # Reset internal counter (prevents UI glitches)

    print("✅ All fields cleared successfully.")


clear_button.on_click(clear_checkboxes_and_output)

# Display the clear button and message output
display(widgets.VBox([clear_button, clear_output_message]))

"""# Document Upload"""

import ipywidgets as widgets
from PyPDF2 import PdfMerger
from docx import Document
from fpdf import FPDF
from PIL import Image
import tempfile
import os

# --- Create 10 upload widgets ---
upload_widgets = [widgets.FileUpload(accept='', multiple=False) for _ in range(10)]

# Combine in a VBox
uploads_box = widgets.VBox(upload_widgets)

# Helper to convert files to PDF
def convert_to_pdf(fileinfo, tempdir):
    name = list(fileinfo.value.keys())[0]
    content = fileinfo.value[name]['content']
    extension = name.split('.')[-1].lower()
    filepath = os.path.join(tempdir, name)

    with open(filepath, 'wb') as f:
        f.write(content)

    if extension == 'pdf':
        return filepath
    elif extension == 'docx':
        # Convert DOCX to PDF using FPDF (simplified)
        doc = Document(filepath)
        pdf_path = filepath.replace(f'.{extension}', '.pdf')
        pdf = FPDF()
        pdf.add_page()
        pdf.set_font("Arial", size=12)
        for para in doc.paragraphs:
            pdf.multi_cell(0, 10, para.text)
        pdf.output(pdf_path)
        return pdf_path
    elif extension in ['txt']:
        text = content.decode('utf-8')
        pdf_path = filepath.replace(f'.{extension}', '.pdf')
        pdf = FPDF()
        pdf.add_page()
        pdf.set_font("Arial", size=12)
        for line in text.splitlines():
            pdf.cell(200, 10, txt=line, ln=True)
        pdf.output(pdf_path)
        return pdf_path
    elif extension in ['png', 'jpg', 'jpeg']:
        image = Image.open(filepath)
        pdf_path = filepath.replace(f'.{extension}', '.pdf')
        image.convert('RGB').save(pdf_path)
        return pdf_path
    else:
        print(f"Unsupported file format: {extension}")
        return None

"""# PDF Previewer"""

from IPython.display import display
from pdf2image import convert_from_path
from PIL import Image  # <-- Add this correct import
import tempfile


def preview_pdf():
    filename = generate_pdf_with_wrapping()

    with tempfile.TemporaryDirectory() as tempdir:
        images = convert_from_path(filename, output_folder=tempdir)
        for image in images:
            display(image)  # <-- just display the PIL image directly

"""# PDF Generation"""

from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.platypus import SimpleDocTemplate, Paragraph
from reportlab.lib import colors

def generate_pdf_with_wrapping(form_data, argument, filename="grievance_output.pdf"):
    # Set up the PDF document with wrapping
    doc = SimpleDocTemplate(filename, pagesize=letter)
    story = []

    # Get sample styles for formatting text
    styles = getSampleStyleSheet()
    style = styles["Normal"]

    # Add title
    title = Paragraph("<b>Grievance Summary</b>", style)
    story.append(title)

    # Create a dictionary to organize what to print
    printable_data = {
        "Steward": form_data.get('steward_name', ''),
        "Employee": form_data.get('employee_name', ''),
        "Appraisal Year": form_data.get('appraisal_year', ''),
        "Rating Received": form_data.get('rating_received', ''),
        "Previous Rating": form_data.get('previous_rating', ''),
        "Issue Description": form_data.get('issue_description', ''),
        "Desired Outcome": form_data.get('desired_outcome', ''),
        "Date Received": str(form_data.get('date_received', '')),
        "File-By Date": str(form_data.get('file_by_date', '')),
        "Generated Argument": argument or "No argument generated"
    }

    # Loop through the organized data
    for label, value in printable_data.items():
        paragraph_text = f"<b>{label}:</b> {value}"
        paragraph = Paragraph(paragraph_text, style)
        story.append(paragraph)

    # Build the PDF
    doc.build(story)
    return filename

"""# PDF Export"""

from google.colab import files
from IPython.display import display
from pdf2image import convert_from_path
from PyPDF2 import PdfMerger
from docx import Document
from fpdf import FPDF
from PIL import Image
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.platypus import SimpleDocTemplate, Paragraph
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from textwrap import wrap
import os
import tempfile
import re



def convert_to_pdf(file_path):
    file_ext = os.path.splitext(file_path)[1].lower()
    output_pdf_path = os.path.splitext(file_path)[0] + "_converted.pdf"
    styles = getSampleStyleSheet()
    style = styles["Normal"]

    doc = SimpleDocTemplate(output_pdf_path, pagesize=letter)
    story = []

    try:
        if file_ext == ".txt":
            with open(file_path, "r", encoding="utf-8") as f:
                for line in f:
                    story.append(Paragraph(line.strip(), style))
                    story.append(Spacer(1, 12))

        elif file_ext == ".docx":
            from docx import Document
            docx = Document(file_path)
            for para in docx.paragraphs:
                if para.text.strip():
                    story.append(Paragraph(para.text, style))
                    story.append(Spacer(1, 12))

        elif file_ext in [".jpg", ".jpeg", ".png"]:
            from reportlab.platypus import Image as RLImage
            img = RLImage(file_path, width=500, height=500)
            story.append(img)

        else:
            return None  # Unsupported format

        doc.build(story)
        return output_pdf_path

    except Exception as e:
        print(f"Error converting file {file_path}: {e}")
        return None


def merge_uploaded_documents(main_pdf, file_uploaders):
    merger = PdfMerger()
    merger.append(main_pdf)

    for uploader in file_uploaders:
        for filename, uploaded_file in uploader.value.items():
            file_bytes = uploaded_file['content']
            extension = os.path.splitext(filename)[1].lower()

            if extension == '.pdf':
                with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as temp_pdf:
                    temp_pdf.write(file_bytes)
                    merger.append(temp_pdf.name)

            elif extension in ['.docx', '.txt', '.png', '.jpg', '.jpeg']:
                # Step 1: Save the uploaded file to a temporary file
                temp_input_path = os.path.join(tempfile.gettempdir(), filename)
                with open(temp_input_path, "wb") as f:
                    f.write(file_bytes)

                # Step 2: Convert to PDF using updated function
                converted = convert_to_pdf(temp_input_path)

                if converted:
                    merger.append(converted)

    final_path = os.path.join(tempfile.gettempdir(), "merged_grievance_output.pdf")
    merger.write(final_path)
    merger.close()
    return final_path

def generate_pdf_with_wrapping(form_data, argument):
    temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf")
    c = canvas.Canvas(temp_file.name, pagesize=letter)
    width, height = letter
    x = 50
    y = height - 50
    line_height = 14  # line spacing

    def draw_wrapped_text(text, max_width_chars=100, indent=0):
        nonlocal y
        lines = text.split('\n')
        for para in lines:
            wrapped_lines = wrap(para, max_width_chars)
            for line in wrapped_lines:
                if y < 50:  # new page if near bottom
                    c.showPage()
                    y = height - 50
                c.drawString(x + indent, y, line)
                y -= line_height
            y -= line_height  # extra space between paragraphs

    # Draw form data with proper wrapping
    for key, value in form_data.items():
        key_text = f"{key.replace('_', ' ').title()}: "
        wrapped_lines = wrap(str(value), 100)  # Adjust width as needed
        key_width = c.stringWidth(key_text, "Helvetica-Bold", 10)

        if y < 50:
            c.showPage()
            y = height - 50

        # Draw key in bold
        c.setFont("Helvetica-Bold", 10)
        c.drawString(x, y, key_text)

        # Draw wrapped value lines
        c.setFont("Helvetica", 10)
        if wrapped_lines:
            # First line next to key
            c.drawString(x + key_width, y, wrapped_lines[0])
            y -= line_height

            # Remaining lines indented
            for line in wrapped_lines[1:]:
                if y < 50:
                    c.showPage()
                    y = height - 50
                c.drawString(x + key_width, y, line)
                y -= line_height
        else:
            y -= line_height

        y -= line_height  # extra space after each field

    # Add argument section
    if y < 50:
        c.showPage()
        y = height - 50

    c.setFont("Helvetica-Bold", 12)
    c.drawString(x, y, "Argument:")
    y -= line_height
    c.setFont("Helvetica", 10)
    draw_wrapped_text(argument)

    c.save()
    return temp_file.name

def collect_form_data():
    form_data = {
        "Steward": steward_name.value,
        "Employee": employee_name.value,
        "Appraisal Year": appraisal_year.value,
        "Rating Received": rating_received.value,
        "Previous Rating": previous_rating.value,
        "Issue Description": issue_description.value,
        "Desired Outcome": desired_outcome.value,
        "Date Received": str(date_received.value)
    }

    # NEW: Gather articles and arguments from checkboxes
    selected_articles = []
    argument_parts = []

    for cb in checkboxes:
        if cb.value:
            item = violation_map.get(cb.description)
            if item:
                selected_articles.extend(item["articles"])
                argument_parts.append(item["argument"])

    if selected_articles:
        form_data["Articles of Violation"] = ", ".join(set(selected_articles))

    # Combine all argument pieces into a single string
    argument = "\n\n".join(argument_parts)
    if 'generated_argument' in globals() and generated_argument.strip():
        argument = f"{generated_argument.strip()}\n\n{argument}"

    return form_data, argument, file_uploaders

def preview_pdf():
    form_data, argument, _ = collect_form_data()
    filename = generate_pdf_with_wrapping(form_data, argument)

    with tempfile.TemporaryDirectory() as tempdir:
        images = convert_from_path(filename, output_folder=tempdir)
        for image in images:
            display(image)

def export_pdf():
    form_data, argument, file_uploaders = collect_form_data()
    main_pdf = generate_pdf_with_wrapping(form_data, argument)
    merged_pdf = merge_uploaded_documents(main_pdf, file_uploaders)

    merger = PdfMerger()
    merger.append(main_pdf)

    # Loop through uploaded files and process them
    for uploader in file_uploaders:
        if uploader.value:
            for name, file_info in uploader.value.items():
                uploaded_file = file_info['content']
                file_ext = name.lower().split('.')[-1]
                temp_input_path = f"/tmp/{name}"

                with open(temp_input_path, 'wb') as f:
                    f.write(uploaded_file)

                if file_ext != 'pdf':
                    converted_path = convert_to_pdf(temp_input_path)
                    if converted_path:
                        merger.append(converted_path)
                else:
                    merger.append(temp_input_path)

    # ✅ Custom filename based on Employee name and Appraisal Year
    employee_name_safe = re.sub(r'[^\w\s-]', '', form_data["Employee"]).strip().replace(" ", "_")
    appraisal_year_safe = str(form_data["Appraisal Year"]).strip()
    final_filename = f"{employee_name_safe}-{appraisal_year_safe}-Argument.pdf"

    merger.write(final_filename)
    merger.close()

    files.download(final_filename)

# Button UI
preview_button = widgets.Button(description='Preview PDF', button_style='info')
export_button = widgets.Button(description='Export PDF', button_style='success')

preview_button.on_click(lambda b: preview_pdf())
export_button.on_click(lambda b: export_pdf())

display(widgets.HBox([preview_button, export_button]))